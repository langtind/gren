package cli

import (
	"context"
	"flag"
	"fmt"
	"os"
	"strings"
)

// handleCompletion generates shell completion scripts
func (c *CLI) handleCompletion(args []string) error {
	fs := flag.NewFlagSet("completion", flag.ExitOnError)

	fs.Usage = func() {
		fmt.Fprintf(fs.Output(), "Usage: gren completion <shell>\n")
		fmt.Fprintf(fs.Output(), "\nGenerate shell completion scripts\n\n")
		fmt.Fprintf(fs.Output(), "Supported shells: bash, zsh, fish\n\n")
		fmt.Fprintf(fs.Output(), "Examples:\n")
		fmt.Fprintf(fs.Output(), "  # Bash\n")
		fmt.Fprintf(fs.Output(), "  gren completion bash > /etc/bash_completion.d/gren\n")
		fmt.Fprintf(fs.Output(), "\n")
		fmt.Fprintf(fs.Output(), "  # Zsh\n")
		fmt.Fprintf(fs.Output(), "  gren completion zsh > \"${fpath[1]}/_gren\"\n")
		fmt.Fprintf(fs.Output(), "\n")
		fmt.Fprintf(fs.Output(), "  # Fish\n")
		fmt.Fprintf(fs.Output(), "  gren completion fish > ~/.config/fish/completions/gren.fish\n")
	}

	if err := fs.Parse(args); err != nil {
		return err
	}

	if fs.NArg() == 0 {
		fs.Usage()
		return fmt.Errorf("shell type required")
	}

	shell := fs.Arg(0)
	switch shell {
	case "bash":
		fmt.Print(bashCompletionScript)
	case "zsh":
		fmt.Print(zshCompletionScript)
	case "fish":
		fmt.Print(fishCompletionScript)
	default:
		return fmt.Errorf("unsupported shell: %s (supported: bash, zsh, fish)", shell)
	}

	return nil
}

// getWorktreeNames returns a list of worktree names for completion
func (c *CLI) getWorktreeNames() []string {
	ctx := context.Background()
	worktrees, err := c.worktreeManager.ListWorktrees(ctx)
	if err != nil {
		return nil
	}

	names := make([]string, 0, len(worktrees))
	for _, wt := range worktrees {
		names = append(names, wt.Name)
	}
	return names
}

// getBranchNames returns a list of branch names for completion
func (c *CLI) getBranchNames() []string {
	ctx := context.Background()
	worktrees, err := c.worktreeManager.ListWorktrees(ctx)
	if err != nil {
		return nil
	}

	names := make([]string, 0, len(worktrees))
	for _, wt := range worktrees {
		if wt.Branch != "" && wt.Branch != "(detached)" && wt.Branch != "(bare)" {
			names = append(names, wt.Branch)
		}
	}
	return names
}

// handleCompletionQuery handles dynamic completion queries from shells
func (c *CLI) handleCompletionQuery(args []string) error {
	if len(args) < 2 {
		return nil
	}

	queryType := args[0]
	// word := args[1] // Current word being completed

	switch queryType {
	case "worktrees":
		for _, name := range c.getWorktreeNames() {
			fmt.Println(name)
		}
	case "branches":
		for _, name := range c.getBranchNames() {
			fmt.Println(name)
		}
	case "commands":
		commands := []string{
			"create", "list", "delete", "cleanup", "init",
			"navigate", "switch", "cd", "nav",
			"compare", "merge", "for-each", "step",
			"marker", "statusline", "shell-init", "completion",
			"setup-claude-plugin",
		}
		for _, cmd := range commands {
			fmt.Println(cmd)
		}
	}

	return nil
}

const bashCompletionScript = `# gren bash completion
# Generated by gren completion bash

_gren_completions() {
    local cur prev words cword
    _init_completion || return

    local commands="create list delete cleanup init navigate switch cd nav compare merge for-each step marker statusline shell-init completion setup-claude-plugin"

    case $cword in
        1)
            COMPREPLY=($(compgen -W "$commands" -- "$cur"))
            return 0
            ;;
    esac

    case ${words[1]} in
        delete|compare|navigate|switch|cd|nav)
            # Complete with worktree names
            local worktrees
            worktrees=$(COMPLETE=1 gren __complete worktrees "$cur" 2>/dev/null)
            COMPREPLY=($(compgen -W "$worktrees" -- "$cur"))
            return 0
            ;;
        create)
            case $prev in
                -b|--base)
                    # Complete with branch names
                    local branches
                    branches=$(COMPLETE=1 gren __complete branches "$cur" 2>/dev/null)
                    COMPREPLY=($(compgen -W "$branches" -- "$cur"))
                    return 0
                    ;;
                *)
                    COMPREPLY=($(compgen -W "-n -b --branch --existing --dir -x" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
        merge)
            case $prev in
                merge)
                    # Complete with branch names for target
                    local branches
                    branches=$(COMPLETE=1 gren __complete branches "$cur" 2>/dev/null)
                    COMPREPLY=($(compgen -W "$branches" -- "$cur"))
                    return 0
                    ;;
                *)
                    COMPREPLY=($(compgen -W "--no-squash --no-remove --no-verify --no-rebase -y -f" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
        list)
            COMPREPLY=($(compgen -W "-v" -- "$cur"))
            return 0
            ;;
        cleanup)
            COMPREPLY=($(compgen -W "-f --force-delete --dry-run" -- "$cur"))
            return 0
            ;;
        shell-init|completion)
            COMPREPLY=($(compgen -W "bash zsh fish" -- "$cur"))
            return 0
            ;;
        marker)
            case ${words[2]} in
                set)
                    COMPREPLY=($(compgen -W "working waiting idle -branch" -- "$cur"))
                    return 0
                    ;;
                clear|get)
                    COMPREPLY=($(compgen -W "-branch -all" -- "$cur"))
                    return 0
                    ;;
                *)
                    COMPREPLY=($(compgen -W "set clear get list" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
        step)
            case ${words[2]} in
                commit|squash)
                    COMPREPLY=($(compgen -W "-m --llm" -- "$cur"))
                    return 0
                    ;;
                *)
                    COMPREPLY=($(compgen -W "commit squash" -- "$cur"))
                    return 0
                    ;;
            esac
            ;;
    esac
}

complete -F _gren_completions gren
`

const zshCompletionScript = `#compdef gren

# gren zsh completion
# Generated by gren completion zsh

_gren() {
    local -a commands
    commands=(
        'create:Create a new worktree'
        'list:List all worktrees'
        'delete:Delete a worktree'
        'cleanup:Delete all stale worktrees'
        'init:Initialize gren in repository'
        'navigate:Navigate to a worktree'
        'switch:Navigate to a worktree'
        'cd:Navigate to a worktree'
        'compare:Compare changes between worktrees'
        'merge:Merge current worktree into target'
        'for-each:Run command in all worktrees'
        'step:Commit/squash operations'
        'marker:Manage Claude activity markers'
        'statusline:Output status for shell prompts'
        'shell-init:Generate shell integration'
        'completion:Generate completion scripts'
        'setup-claude-plugin:Create Claude plugin hooks'
    )

    _arguments -C \
        '1: :->command' \
        '*: :->args'

    case $state in
        command)
            _describe -t commands 'gren commands' commands
            ;;
        args)
            case $words[2] in
                delete|compare|navigate|switch|cd|nav)
                    local -a worktrees
                    worktrees=(${(f)"$(COMPLETE=1 gren __complete worktrees "" 2>/dev/null)"})
                    _describe -t worktrees 'worktrees' worktrees
                    ;;
                create)
                    _arguments \
                        '-n[Worktree name]:name:' \
                        '-b[Base branch]:branch:' \
                        '--branch[Branch name]:branch:' \
                        '--existing[Use existing branch]' \
                        '--dir[Worktree directory]:directory:_files -/' \
                        '-x[Execute command]:command:'
                    ;;
                merge)
                    local -a branches
                    branches=(${(f)"$(COMPLETE=1 gren __complete branches "" 2>/dev/null)"})
                    _arguments \
                        '1:target branch:($branches)' \
                        '--no-squash[Preserve individual commits]' \
                        '--no-remove[Keep worktree after merge]' \
                        '--no-verify[Skip hooks]' \
                        '--no-rebase[Skip rebase]' \
                        '-y[Skip confirmation]' \
                        '-f[Force merge]'
                    ;;
                list)
                    _arguments '-v[Verbose output]'
                    ;;
                cleanup)
                    _arguments \
                        '-f[Skip confirmation]' \
                        '--force-delete[Force delete]' \
                        '--dry-run[Show what would be deleted]'
                    ;;
                shell-init|completion)
                    _arguments '1:shell:(bash zsh fish)'
                    ;;
                marker)
                    local -a subcommands
                    subcommands=(
                        'set:Set a marker'
                        'clear:Clear a marker'
                        'get:Get a marker'
                        'list:List all markers'
                    )
                    _arguments -C \
                        '1: :->subcommand' \
                        '*: :->subargs'
                    case $state in
                        subcommand)
                            _describe -t subcommands 'marker subcommands' subcommands
                            ;;
                        subargs)
                            case $words[3] in
                                set)
                                    _arguments \
                                        '1:type:(working waiting idle)' \
                                        '-branch[Branch name]:branch:'
                                    ;;
                                clear|get)
                                    _arguments \
                                        '-branch[Branch name]:branch:' \
                                        '-all[Clear all]'
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                step)
                    local -a subcommands
                    subcommands=(
                        'commit:Stage and commit changes'
                        'squash:Squash commits'
                    )
                    _arguments -C \
                        '1: :->subcommand' \
                        '*: :->subargs'
                    case $state in
                        subcommand)
                            _describe -t subcommands 'step subcommands' subcommands
                            ;;
                        subargs)
                            _arguments \
                                '-m[Commit message]:message:' \
                                '--llm[Use LLM for message]'
                            ;;
                    esac
                    ;;
                for-each)
                    _arguments \
                        '--skip-current[Skip current worktree]' \
                        '--skip-main[Skip main worktree]' \
                        '--[Command separator]:command:_command_names'
                    ;;
            esac
            ;;
    esac
}

_gren "$@"
`

const fishCompletionScript = `# gren fish completion
# Generated by gren completion fish

# Disable file completion by default
complete -c gren -f

# Main commands
complete -c gren -n '__fish_use_subcommand' -a create -d 'Create a new worktree'
complete -c gren -n '__fish_use_subcommand' -a list -d 'List all worktrees'
complete -c gren -n '__fish_use_subcommand' -a delete -d 'Delete a worktree'
complete -c gren -n '__fish_use_subcommand' -a cleanup -d 'Delete all stale worktrees'
complete -c gren -n '__fish_use_subcommand' -a init -d 'Initialize gren in repository'
complete -c gren -n '__fish_use_subcommand' -a navigate -d 'Navigate to a worktree'
complete -c gren -n '__fish_use_subcommand' -a switch -d 'Navigate to a worktree'
complete -c gren -n '__fish_use_subcommand' -a cd -d 'Navigate to a worktree'
complete -c gren -n '__fish_use_subcommand' -a compare -d 'Compare changes between worktrees'
complete -c gren -n '__fish_use_subcommand' -a merge -d 'Merge current worktree into target'
complete -c gren -n '__fish_use_subcommand' -a for-each -d 'Run command in all worktrees'
complete -c gren -n '__fish_use_subcommand' -a step -d 'Commit/squash operations'
complete -c gren -n '__fish_use_subcommand' -a marker -d 'Manage Claude activity markers'
complete -c gren -n '__fish_use_subcommand' -a statusline -d 'Output status for shell prompts'
complete -c gren -n '__fish_use_subcommand' -a shell-init -d 'Generate shell integration'
complete -c gren -n '__fish_use_subcommand' -a completion -d 'Generate completion scripts'
complete -c gren -n '__fish_use_subcommand' -a setup-claude-plugin -d 'Create Claude plugin hooks'

# Worktree completions for relevant commands
function __fish_gren_worktrees
    COMPLETE=1 gren __complete worktrees "" 2>/dev/null
end

function __fish_gren_branches
    COMPLETE=1 gren __complete branches "" 2>/dev/null
end

# delete command
complete -c gren -n '__fish_seen_subcommand_from delete' -a '(__fish_gren_worktrees)' -d 'Worktree'
complete -c gren -n '__fish_seen_subcommand_from delete' -s f -d 'Force deletion'
complete -c gren -n '__fish_seen_subcommand_from delete' -l dry-run -d 'Show what would be deleted'

# navigate/switch/cd commands
complete -c gren -n '__fish_seen_subcommand_from navigate switch cd nav' -a '(__fish_gren_worktrees)' -d 'Worktree'

# compare command
complete -c gren -n '__fish_seen_subcommand_from compare' -a '(__fish_gren_worktrees)' -d 'Worktree'
complete -c gren -n '__fish_seen_subcommand_from compare' -l diff -d 'Show unified diff'
complete -c gren -n '__fish_seen_subcommand_from compare' -l apply -d 'Apply all changes'

# create command
complete -c gren -n '__fish_seen_subcommand_from create' -s n -d 'Worktree name' -r
complete -c gren -n '__fish_seen_subcommand_from create' -l branch -d 'Branch name' -r
complete -c gren -n '__fish_seen_subcommand_from create' -s b -d 'Base branch' -ra '(__fish_gren_branches)'
complete -c gren -n '__fish_seen_subcommand_from create' -l existing -d 'Use existing branch'
complete -c gren -n '__fish_seen_subcommand_from create' -l dir -d 'Worktree directory' -ra '(__fish_complete_directories)'
complete -c gren -n '__fish_seen_subcommand_from create' -s x -d 'Execute command' -r

# merge command
complete -c gren -n '__fish_seen_subcommand_from merge' -a '(__fish_gren_branches)' -d 'Target branch'
complete -c gren -n '__fish_seen_subcommand_from merge' -l no-squash -d 'Preserve individual commits'
complete -c gren -n '__fish_seen_subcommand_from merge' -l no-remove -d 'Keep worktree after merge'
complete -c gren -n '__fish_seen_subcommand_from merge' -l no-verify -d 'Skip hooks'
complete -c gren -n '__fish_seen_subcommand_from merge' -l no-rebase -d 'Skip rebase'
complete -c gren -n '__fish_seen_subcommand_from merge' -s y -d 'Skip confirmation'
complete -c gren -n '__fish_seen_subcommand_from merge' -s f -d 'Force merge'

# list command
complete -c gren -n '__fish_seen_subcommand_from list' -s v -d 'Verbose output'

# cleanup command
complete -c gren -n '__fish_seen_subcommand_from cleanup' -s f -d 'Skip confirmation'
complete -c gren -n '__fish_seen_subcommand_from cleanup' -l force-delete -d 'Force delete'
complete -c gren -n '__fish_seen_subcommand_from cleanup' -l dry-run -d 'Show what would be deleted'

# shell-init and completion commands
complete -c gren -n '__fish_seen_subcommand_from shell-init completion' -a 'bash zsh fish' -d 'Shell type'

# marker command subcommands
complete -c gren -n '__fish_seen_subcommand_from marker; and not __fish_seen_subcommand_from set clear get list' -a set -d 'Set a marker'
complete -c gren -n '__fish_seen_subcommand_from marker; and not __fish_seen_subcommand_from set clear get list' -a clear -d 'Clear a marker'
complete -c gren -n '__fish_seen_subcommand_from marker; and not __fish_seen_subcommand_from set clear get list' -a get -d 'Get a marker'
complete -c gren -n '__fish_seen_subcommand_from marker; and not __fish_seen_subcommand_from set clear get list' -a list -d 'List all markers'

# marker set
complete -c gren -n '__fish_seen_subcommand_from marker; and __fish_seen_subcommand_from set' -a 'working waiting idle' -d 'Marker type'
complete -c gren -n '__fish_seen_subcommand_from marker; and __fish_seen_subcommand_from set clear get' -l branch -d 'Branch name' -r

# marker clear
complete -c gren -n '__fish_seen_subcommand_from marker; and __fish_seen_subcommand_from clear' -l all -d 'Clear all markers'

# step command subcommands
complete -c gren -n '__fish_seen_subcommand_from step; and not __fish_seen_subcommand_from commit squash' -a commit -d 'Stage and commit changes'
complete -c gren -n '__fish_seen_subcommand_from step; and not __fish_seen_subcommand_from commit squash' -a squash -d 'Squash commits'

# step commit/squash
complete -c gren -n '__fish_seen_subcommand_from step; and __fish_seen_subcommand_from commit squash' -s m -d 'Commit message' -r
complete -c gren -n '__fish_seen_subcommand_from step; and __fish_seen_subcommand_from commit squash' -l llm -d 'Use LLM for message'

# for-each command
complete -c gren -n '__fish_seen_subcommand_from for-each' -l skip-current -d 'Skip current worktree'
complete -c gren -n '__fish_seen_subcommand_from for-each' -l skip-main -d 'Skip main worktree'
`

// parseCompletionEnv checks if we're in completion mode and returns the word being completed
func parseCompletionEnv() (bool, string) {
	if os.Getenv("COMPLETE") != "" {
		return true, ""
	}
	return false, ""
}

// formatCompletions formats completions for output, filtering by prefix
func formatCompletions(items []string, prefix string) {
	prefix = strings.ToLower(prefix)
	for _, item := range items {
		if prefix == "" || strings.HasPrefix(strings.ToLower(item), prefix) {
			fmt.Println(item)
		}
	}
}
