#!/bin/bash
# wt - Simple git worktree creator

set -e

# Help function
show_help() {
    cat << EOF
wt - Simple git worktree creator

USAGE:
    wt <branch-name> [base-branch]    Create worktree with new branch
    wt                                Interactive mode (choose existing or new branch)
    wt -l | --list                    List existing worktrees
    wt -d | --delete <branch-name>    Delete worktree and branch
    wt -i | --interactive             Launch interactive TUI mode

ARGUMENTS:
    branch-name     Name of new branch (required for create/delete)
    base-branch     Branch to base from (default: main)

OPTIONS:
    -l, --list      List all existing worktrees
    -d, --delete    Delete specified worktree and branch
    -i, --interactive Launch interactive TUI mode (requires gum)
    -h, --help      Show this help message

EXAMPLES:
    wt my-feature           Create worktree with new branch
    wt hotfix develop       Create new branch from develop
    wt                      Interactive mode (choose branch)
    wt --list               Show all worktrees
    wt --delete my-feature  Delete worktree
    wt --interactive        Launch interactive mode

The worktree will be created in: ../PROJECT-worktrees/BRANCH-NAME
EOF
}

# List worktrees function
list_worktrees() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "‚ùå Not in a git repository!"
        exit 1
    fi
    
    echo "üå≥ Git worktrees:"
    
    local current_path=""
    local current_branch=""
    
    git worktree list --porcelain | while IFS= read -r line; do
        if [[ $line == worktree* ]]; then
            current_path=${line#worktree }
            # If this is main repo, show it differently
            if [[ "$current_path" == "$(git rev-parse --show-toplevel)" ]]; then
                echo "üìÅ Main repo: $(basename "$current_path")"
            else
                echo "üìÅ Worktree: $(basename "$current_path")"
            fi
            echo "   üìç Path: $current_path"
        elif [[ $line == branch* ]]; then
            current_branch=${line#branch refs/heads/}
            if [[ $current_branch != "refs/heads/"* ]]; then
                echo "   üåø Branch: $current_branch"
            else
                echo "   üîÄ Status: (detached HEAD)"
            fi
        elif [[ $line == HEAD* ]]; then
            if [[ -z "$current_branch" || "$current_branch" == "refs/heads/"* ]]; then
                local commit_hash=${line#HEAD }
                echo "   üîÄ Commit: ${commit_hash:0:8}"
            fi
        fi
        
        # Add separator between worktrees
        if [[ $line == "" ]]; then
            echo ""
        fi
    done
}

# Delete worktree function
delete_worktree() {
    local branch_name="$1"
    
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "‚ùå Not in a git repository!"
        exit 1
    fi
    
    if [[ -z "$branch_name" ]]; then
        echo "‚ùå Branch name required for deletion!"
        echo "Usage: wt --delete <branch-name>"
        exit 1
    fi
    
    # Get repo info
    local repo_root=$(git rev-parse --show-toplevel)
    local project_name=$(basename "$repo_root")
    local parent_dir=$(dirname "$repo_root")
    local worktree_path="${parent_dir}/${project_name}-worktrees/${branch_name}"
    
    # Check if worktree exists
    if ! git worktree list | grep -q "$worktree_path"; then
        echo "‚ùå Worktree for branch '$branch_name' not found!"
        echo "Available worktrees:"
        list_worktrees
        exit 1
    fi
    
    echo "üóëÔ∏è  Deleting worktree: $branch_name"
    echo "üìç Path: $worktree_path"
    
    # Remove worktree
    git worktree remove "$worktree_path"
    
    # Delete branch
    git branch -D "$branch_name"
    
    echo "‚úÖ Worktree and branch '$branch_name' deleted successfully!"
}

# Interactive branch selection
interactive_branch_selection() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "‚ùå Not in a git repository!"
        exit 1
    fi
    
    echo "üåø Select branch for worktree:"
    
    # Get all local branches except the current one and ones already in worktrees
    local current_branch=$(git branch --show-current)
    local worktree_branches=()
    
    # Get branches already in worktrees
    while IFS= read -r line; do
        if [[ $line == branch* ]]; then
            branch_name=${line#branch refs/heads/}
            if [[ $branch_name != "refs/heads/"* ]]; then
                worktree_branches+=("$branch_name")
            fi
        fi
    done < <(git worktree list --porcelain)
    
    # Get available branches
    local available_branches=()
    while IFS= read -r branch; do
        branch=$(echo "$branch" | sed 's/^[* ] //')
        # Skip current branch and branches already in worktrees
        if [[ "$branch" != "$current_branch" ]]; then
            local is_in_worktree=false
            for wt_branch in "${worktree_branches[@]}"; do
                if [[ "$branch" == "$wt_branch" ]]; then
                    is_in_worktree=true
                    break
                fi
            done
            if [[ "$is_in_worktree" == false ]]; then
                available_branches+=("$branch")
            fi
        fi
    done < <(git branch --format='%(refname:short)')
    
    # Add "New branch" option
    local choices=("üÜï New branch")
    for branch in "${available_branches[@]}"; do
        choices+=("$branch")
    done
    
    if [[ ${#choices[@]} -eq 1 ]]; then
        echo "‚ÑπÔ∏è  No existing branches available for worktree"
        echo "Current branch: $current_branch"
        echo "All other branches are already in worktrees"
        echo ""
        create_new_branch_worktree
        return
    fi
    
    local selected_branch
    if command -v gum >/dev/null 2>&1; then
        selected_branch=$(printf '%s\n' "${choices[@]}" | gum choose --limit=1)
    else
        echo ""
        for i in "${!choices[@]}"; do
            echo "$((i+1))) ${choices[i]}"
        done
        echo ""
        read -p "Choose (1-${#choices[@]}): " choice_num
        if [[ "$choice_num" =~ ^[0-9]+$ ]] && [[ "$choice_num" -ge 1 ]] && [[ "$choice_num" -le ${#choices[@]} ]]; then
            selected_branch="${choices[$((choice_num-1))]}"
        else
            echo "‚ùå Invalid selection"
            exit 1
        fi
    fi
    
    if [[ "$selected_branch" == "üÜï New branch" ]]; then
        create_new_branch_worktree
    else
        create_existing_branch_worktree "$selected_branch"
    fi
}

# Create worktree with new branch
create_new_branch_worktree() {
    echo ""
    read -p "Enter new branch name: " branch_name
    
    if [[ -z "$branch_name" ]]; then
        echo "‚ùå Branch name cannot be empty!"
        exit 1
    fi
    
    # Validate branch name (reuse existing validation)
    if [[ "$branch_name" =~ [[:space:]] ]]; then
        echo "‚ùå Branch name cannot contain spaces!"
        echo "üí° Use dashes instead: ${branch_name// /-}"
        exit 1
    fi
    
    if [[ "$branch_name" =~ [^a-zA-Z0-9._/-] ]]; then
        echo "‚ùå Branch name contains invalid characters!"
        echo "üí° Use only letters, numbers, dots, dashes, and slashes"
        exit 1
    fi
    
    if [[ "$branch_name" == .* ]] || [[ "$branch_name" == *. ]]; then
        echo "‚ùå Branch name cannot start or end with a dot!"
        exit 1
    fi
    
    if [[ "$branch_name" == *.. ]]; then
        echo "‚ùå Branch name cannot contain consecutive dots!"
        exit 1
    fi
    
    # Check if branch already exists
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        echo "‚ùå Branch '$branch_name' already exists!"
        exit 1
    fi
    
    # Get base branch
    echo ""
    echo "Select base branch:"
    local base_branches=()
    while IFS= read -r branch; do
        branch=$(echo "$branch" | sed 's/^[* ] //')
        base_branches+=("$branch")
    done < <(git branch --format='%(refname:short)')
    
    # Auto-detect default branch
    local default_branch="main"
    if git show-ref --verify --quiet "refs/heads/master"; then
        default_branch="master"
    fi
    
    local selected_base
    if command -v gum >/dev/null 2>&1; then
        selected_base=$(printf '%s\n' "${base_branches[@]}" | gum choose --limit=1)
    else
        echo ""
        for i in "${!base_branches[@]}"; do
            marker=""
            if [[ "${base_branches[i]}" == "$default_branch" ]]; then
                marker=" (default)"
            fi
            echo "$((i+1))) ${base_branches[i]}$marker"
        done
        echo ""
        read -p "Choose base branch (1-${#base_branches[@]}): " choice_num
        if [[ "$choice_num" =~ ^[0-9]+$ ]] && [[ "$choice_num" -ge 1 ]] && [[ "$choice_num" -le ${#base_branches[@]} ]]; then
            selected_base="${base_branches[$((choice_num-1))]}"
        else
            echo "‚ùå Invalid selection"
            exit 1
        fi
    fi
    
    create_worktree "$branch_name" "$selected_base" true
}

# Create worktree with existing branch
create_existing_branch_worktree() {
    local branch_name="$1"
    echo ""
    echo "üåø Creating worktree for existing branch: $branch_name"
    create_worktree "$branch_name" "$branch_name" false
}

# Create worktree function
create_worktree() {
    local branch_name="$1"
    local base_branch="$2"
    local is_new_branch="$3"
    
    # Get repo info
    REPO_ROOT=$(git rev-parse --show-toplevel)
    PROJECT_NAME=$(basename "$REPO_ROOT")
    PARENT_DIR=$(dirname "$REPO_ROOT")
    
    # Setup paths
    WORKTREES_DIR="${PARENT_DIR}/${PROJECT_NAME}-worktrees"
    WORKTREE_PATH="${WORKTREES_DIR}/${branch_name}"
    
    echo "üå≥ Creating worktree for ${PROJECT_NAME}"
    echo "üìÇ Branch: ${branch_name} $(if [[ "$is_new_branch" == true ]]; then echo "(from ${base_branch})"; else echo "(existing)"; fi)"
    echo "üìç Path: ${WORKTREE_PATH}"
    
    # Create worktrees directory
    mkdir -p "$WORKTREES_DIR"
    
    # Create worktree
    if [[ "$is_new_branch" == true ]]; then
        git worktree add -b "$branch_name" "$WORKTREE_PATH" "$base_branch"
    else
        git worktree add "$WORKTREE_PATH" "$branch_name"
    fi
    
    # Navigate to worktree
    cd "$WORKTREE_PATH"
    
    # Copy .env* files from main repo
    echo "üìÅ Copying environment files..."
    for env_file in "${REPO_ROOT}"/.env*; do
        if [[ -f "$env_file" ]]; then
            filename=$(basename "$env_file")
            cp "$env_file" "./$filename"
            echo "  ‚úì Copied $filename"
        fi
    done
    
    # Copy .claude directory if it exists
    if [[ -d "${REPO_ROOT}/.claude" ]]; then
        # Check if any .claude files/directories are in .gitignore
        has_claude_in_gitignore=false
        
        if [[ -f "${REPO_ROOT}/.gitignore" ]]; then
            # Check for any .claude patterns in .gitignore
            if grep -q "\.claude" "${REPO_ROOT}/.gitignore" 2>/dev/null; then
                has_claude_in_gitignore=true
            fi
        fi
        
        if [[ "$has_claude_in_gitignore" == true ]]; then
            echo "üìÅ Copying Claude configuration..."
            mkdir -p ".claude"
            
            # Copy all files from .claude directory
            for claude_file in "${REPO_ROOT}"/.claude/*; do
                if [[ -f "$claude_file" ]]; then
                    filename=$(basename "$claude_file")
                    cp "$claude_file" ".claude/$filename"
                    echo "  ‚úì Copied .claude/$filename"
                fi
            done
            
            # Copy subdirectories if any
            for claude_dir in "${REPO_ROOT}"/.claude/*/; do
                if [[ -d "$claude_dir" ]]; then
                    dirname=$(basename "$claude_dir")
                    cp -r "$claude_dir" ".claude/$dirname"
                    echo "  ‚úì Copied .claude/$dirname/"
                fi
            done
        fi
    fi
    
    # Auto-detect and install dependencies
    if [ -f "package.json" ]; then
        # Check main repo for lock files since worktree might not have them yet
        if [ -f "${REPO_ROOT}/bun.lockb" ] || [ -f "${REPO_ROOT}/bun.lock" ]; then
            echo "üì¶ Installing dependencies with bun..."
            bun install
        elif [ -f "${REPO_ROOT}/pnpm-lock.yaml" ]; then
            echo "üì¶ Installing dependencies with pnpm..."
            pnpm install
        elif [ -f "${REPO_ROOT}/yarn.lock" ]; then
            echo "üì¶ Installing dependencies with yarn..."
            yarn install
        else
            echo "üì¶ Installing dependencies with npm..."
            npm install
        fi
    fi
    
    # Run direnv allow if .envrc exists
    if [ -f ".envrc" ] && command -v direnv >/dev/null 2>&1; then
        echo "üîß Running direnv allow..."
        direnv allow
    fi
    
    # Ask what to do next
    echo ""
    echo "‚úÖ Worktree '$branch_name' created successfully!"
    echo "üìç Path: $WORKTREE_PATH"
    echo ""
    
    if command -v gum >/dev/null 2>&1; then
        # Use gum for interactive selection
        gum style --foreground=33 "What would you like to do next?"
        choices=("Open in Cursor" "Open in VS Code" "Open in Claude Code" "Open in Finder" "Nothing")
        choice=$(printf '%s\n' "${choices[@]}" | gum choose --limit=1)
        
        case "$choice" in
            "Open in Cursor")
                if command -v cursor >/dev/null 2>&1; then
                    echo "üöÄ Opening in Cursor..."
                    cursor .
                else
                    echo "‚ùå Cursor not found!"
                fi
                ;;
            "Open in VS Code")
                if command -v code >/dev/null 2>&1; then
                    echo "üöÄ Opening in VS Code..."
                    code .
                else
                    echo "‚ùå VS Code not found!"
                fi
                ;;
            "Open in Claude Code")
                if command -v claude >/dev/null 2>&1; then
                    echo "üöÄ Opening in Claude Code..."
                    claude .
                else
                    echo "‚ùå Claude Code not found!"
                fi
                ;;
            "Open in Finder")
                echo "üöÄ Opening in Finder..."
                open .
                ;;
            "Nothing"|"")
                echo "üëç All done! cd $WORKTREE_PATH"
                ;;
        esac
    else
        # Fallback for when gum is not available
        echo "What would you like to do next?"
        echo "1) Open in Cursor"
        echo "2) Open in VS Code" 
        echo "3) Open in Claude Code"
        echo "4) Open in Finder"
        echo "5) Nothing"
        echo ""
        read -p "Choose (1-5): " choice
        
        case "$choice" in
            1)
                if command -v cursor >/dev/null 2>&1; then
                    echo "üöÄ Opening in Cursor..."
                    cursor .
                else
                    echo "‚ùå Cursor not found!"
                fi
                ;;
            2)
                if command -v code >/dev/null 2>&1; then
                    echo "üöÄ Opening in VS Code..."
                    code .
                else
                    echo "‚ùå VS Code not found!"
                fi
                ;;
            3)
                if command -v claude >/dev/null 2>&1; then
                    echo "üöÄ Opening in Claude Code..."
                    claude .
                else
                    echo "‚ùå Claude Code not found!"
                fi
                ;;
            4)
                echo "üöÄ Opening in Finder..."
                open .
                ;;
            5|"")
                echo "üëç All done! cd $WORKTREE_PATH"
                ;;
            *)
                echo "üëç All done! cd $WORKTREE_PATH"
                ;;
        esac
    fi
}

# Parse arguments first (before git check for help)
if [[ $# -eq 0 ]]; then
    # No arguments - run interactive mode
    interactive_branch_selection
    exit 0
elif [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    show_help
    exit 0
fi

# Handle list option
if [[ "$1" == "-l" ]] || [[ "$1" == "--list" ]]; then
    list_worktrees
    exit 0
fi

# Handle delete option
if [[ "$1" == "-d" ]] || [[ "$1" == "--delete" ]]; then
    delete_worktree "$2"
    exit 0
fi

# Handle interactive option
if [[ "$1" == "-i" ]] || [[ "$1" == "--interactive" ]]; then
    if ! command -v gum >/dev/null 2>&1; then
        echo "‚ùå Interactive mode requires 'gum' to be installed!"
        echo "Install with: brew install gum"
        exit 1
    fi
    exec wt-tui
fi

# Check if we're in a git repo (for create operation)
if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "‚ùå Not in a git repository!"
    exit 1
fi

# Parse arguments for create
BRANCH_NAME="$1"
BASE_BRANCH="${2:-main}"

# Validate branch name
if [[ "$BRANCH_NAME" =~ [[:space:]] ]]; then
    echo "‚ùå Branch name cannot contain spaces!"
    echo "üí° Use dashes instead: ${BRANCH_NAME// /-}"
    exit 1
fi

if [[ "$BRANCH_NAME" =~ [^a-zA-Z0-9._/-] ]]; then
    echo "‚ùå Branch name contains invalid characters!"
    echo "üí° Use only letters, numbers, dots, dashes, and slashes"
    exit 1
fi

if [[ "$BRANCH_NAME" == .* ]] || [[ "$BRANCH_NAME" == *. ]]; then
    echo "‚ùå Branch name cannot start or end with a dot!"
    exit 1
fi

if [[ "$BRANCH_NAME" == *.. ]]; then
    echo "‚ùå Branch name cannot contain consecutive dots!"
    exit 1
fi

# Check if branch already exists
if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
    echo "‚ùå Branch '$BRANCH_NAME' already exists!"
    exit 1
fi

# Auto-detect default branch if not specified
if [[ "$BASE_BRANCH" == "main" ]] && ! git show-ref --verify --quiet "refs/heads/main"; then
    if git show-ref --verify --quiet "refs/heads/master"; then
        BASE_BRANCH="master"
    fi
fi

# Check if base branch exists
if ! git show-ref --verify --quiet "refs/heads/$BASE_BRANCH"; then
    echo "‚ùå Base branch '$BASE_BRANCH' does not exist!"
    exit 1
fi

# Create worktree with new branch
create_worktree "$BRANCH_NAME" "$BASE_BRANCH" true