#!/bin/bash
# wt-tui - Interactive git worktree manager with gum

set -e

# Colors
RED="\033[31m"
GREEN="\033[32m"
BLUE="\033[34m"
YELLOW="\033[33m"
RESET="\033[0m"

# Check if gum is available
if ! command -v gum >/dev/null 2>&1; then
    echo -e "${RED}‚ùå gum is required but not installed!"
    echo -e "${RESET}Install with: brew install gum"
    exit 1
fi

# Check if we're in a git repo
check_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        gum style --foreground=196 "‚ùå Not in a git repository!"
        exit 1
    fi
}

# Get repo info
get_repo_info() {
    REPO_ROOT=$(git rev-parse --show-toplevel)
    PROJECT_NAME=$(basename "$REPO_ROOT")
    PARENT_DIR=$(dirname "$REPO_ROOT")
    WORKTREES_DIR="${PARENT_DIR}/${PROJECT_NAME}-worktrees"
}

# List existing worktrees
list_worktrees() {
    local worktrees=()
    while IFS= read -r line; do
        if [[ $line == *" "* ]]; then
            path=$(echo "$line" | awk '{print $1}')
            branch=$(echo "$line" | awk '{print $3}' | sed 's/\[//' | sed 's/\]//')
            if [[ "$path" != "$REPO_ROOT" ]]; then
                worktrees+=("Worktree: $(basename "$path") | Branch: $branch")
            fi
        fi
    done < <(git worktree list)
    
    printf '%s\n' "${worktrees[@]}"
}

# Get available branches for base selection
get_branches() {
    git branch -r | grep -v HEAD | sed 's/origin\///' | sed 's/^[* ]*//' | sort -u
}

# Create new worktree
create_worktree() {
    # Get branch name with validation
    local branch_name
    while true; do
        branch_name=$(gum input --placeholder "Enter branch name (e.g., my-feature)")
        
        if [[ -z "$branch_name" ]]; then
            gum style --foreground=196 "‚ùå Branch name cannot be empty!"
            continue
        fi
        
        # Validate branch name
        if [[ "$branch_name" =~ [[:space:]] ]]; then
            gum style --foreground=196 "‚ùå Branch name cannot contain spaces!"
            gum style --foreground=33 "üí° Use dashes instead: ${branch_name// /-}"
            continue
        fi
        
        if [[ "$branch_name" =~ [^a-zA-Z0-9._/-] ]]; then
            gum style --foreground=196 "‚ùå Branch name contains invalid characters!"
            gum style --foreground=33 "üí° Use only letters, numbers, dots, dashes, and slashes"
            continue
        fi
        
        if [[ "$branch_name" == .* ]] || [[ "$branch_name" == *. ]]; then
            gum style --foreground=196 "‚ùå Branch name cannot start or end with a dot!"
            continue
        fi
        
        if [[ "$branch_name" == *.. ]]; then
            gum style --foreground=196 "‚ùå Branch name cannot contain consecutive dots!"
            continue
        fi
        
        # All validations passed
        break
    done
    
    # Check if worktree already exists
    local worktree_path="${WORKTREES_DIR}/${branch_name}"
    if [[ -d "$worktree_path" ]]; then
        gum style --foreground=196 "‚ùå Worktree '$branch_name' already exists!"
        return 1
    fi
    
    # Check if current branch has uncommitted changes first
    local current_branch
    current_branch=$(git branch --show-current)
    local has_changes=false
    
    if [[ -n "$current_branch" ]]; then
        # Check for modified tracked files
        if ! git diff-index --quiet HEAD -- 2>/dev/null; then
            has_changes=true
        fi
        
        # Check for untracked files
        if [[ -n $(git ls-files --others --exclude-standard 2>/dev/null) ]]; then
            has_changes=true
        fi
    fi
    
    # Show warning before branch selection if current branch has changes
    if [[ "$has_changes" == true ]]; then
        echo ""
        
        # Check what type of changes we have
        local has_tracked_changes=false
        local has_untracked_files=false
        
        if ! git diff-index --quiet HEAD -- 2>/dev/null; then
            has_tracked_changes=true
        fi
        
        if [[ -n $(git ls-files --others --exclude-standard 2>/dev/null) ]]; then
            has_untracked_files=true
        fi
        
        if [[ "$has_tracked_changes" == true && "$has_untracked_files" == true ]]; then
            # Both types
            gum style --foreground=33 --border=rounded --padding="1 2" "‚ö†Ô∏è  Working directory has changes and untracked files"
            echo "   Worktree will be based on last commit only"
            echo "   Local changes stay in main repository"
        elif [[ "$has_tracked_changes" == true ]]; then
            # Only tracked changes
            gum style --foreground=33 --border=rounded --padding="1 2" "‚ö†Ô∏è  Current branch '$current_branch' has uncommitted changes"
            echo "   Worktree will be based on last commit only"
            echo "   Local changes stay in main repository"
        else
            # Only untracked files
            gum style --foreground=33 --border=rounded --padding="1 2" "‚ö†Ô∏è  Working directory has untracked files"
            echo "   Worktree will be based on last commit only"
            echo "   Untracked files stay in main repository"
        fi
        echo ""
    fi
    
    # Select base branch
    gum style --foreground=33 "Select base branch:"
    
    # Get all available branches dynamically
    local all_branches=()
    
    # Add current branch first if it exists
    if [[ -n "$current_branch" ]]; then
        if [[ "$has_changes" == true ]]; then
            all_branches+=("$current_branch (current - working directory has changes)")
        else
            all_branches+=("$current_branch (current)")
        fi
    fi
    
    # Add local branches (excluding current if already added)
    while IFS= read -r branch; do
        branch=$(echo "$branch" | sed 's/^[* ] //')
        if [[ "$branch" != "$current_branch" && "$branch" != "" ]]; then
            all_branches+=("$branch")
        fi
    done < <(git branch --format='%(refname:short)')
    
    # Add popular remote branches if they exist locally
    for remote_branch in "origin/main" "origin/develop" "origin/master"; do
        if git show-ref --verify --quiet "refs/remotes/$remote_branch"; then
            local local_name=${remote_branch#origin/}
            # Only add if not already in local branches
            local already_exists=false
            for existing in "${all_branches[@]}"; do
                if [[ "$existing" == "$local_name"* ]]; then
                    already_exists=true
                    break
                fi
            done
            if [[ "$already_exists" == false ]]; then
                all_branches+=("$local_name (from $remote_branch)")
            fi
        fi
    done
    
    local base_branch_selection
    base_branch_selection=$(printf '%s\n' "${all_branches[@]}" | gum choose --limit=1)
    
    # Extract actual branch name from selection
    local base_branch
    if [[ "$base_branch_selection" == *" (current - working directory has changes)" ]]; then
        base_branch=${base_branch_selection% (current - working directory has changes)}
    elif [[ "$base_branch_selection" == *" (current)" ]]; then
        base_branch=${base_branch_selection% (current)}
    elif [[ "$base_branch_selection" == *" (from "* ]]; then
        base_branch=${base_branch_selection% (from *)}
    else
        base_branch="$base_branch_selection"
    fi
    
    if [[ -z "$base_branch" ]]; then
        gum style --foreground=196 "‚ùå No base branch selected!"
        return 1
    fi
    
    # Create worktree with loading animation
    gum spin --spinner dot --title "Creating worktree '$branch_name' from '$base_branch'..." -- \
        git worktree add -b "$branch_name" "$worktree_path" "$base_branch"
    
    # Navigate to worktree
    cd "$worktree_path"
    
    # Copy .env* files from main repo
    gum style --foreground=33 "üìÅ Copying environment files..."
    local copied_files=()
    for env_file in "${REPO_ROOT}"/.env*; do
        if [[ -f "$env_file" ]]; then
            filename=$(basename "$env_file")
            cp "$env_file" "./$filename"
            copied_files+=("$filename")
        fi
    done

    if [[ ${#copied_files[@]} -gt 0 ]]; then
        for file in "${copied_files[@]}"; do
            echo "  ‚úì Copied $file"
        done
    else
        echo "  ‚Ä¢ No .env files found"
    fi
    
    # Copy .claude directory if it exists
    if [[ -d "${REPO_ROOT}/.claude" ]]; then
        # Check if any .claude files/directories are in .gitignore
        has_claude_in_gitignore=false
        
        if [[ -f "${REPO_ROOT}/.gitignore" ]]; then
            # Check for any .claude patterns in .gitignore
            if grep -q "\.claude" "${REPO_ROOT}/.gitignore" 2>/dev/null; then
                has_claude_in_gitignore=true
            fi
        fi
        
        if [[ "$has_claude_in_gitignore" == true ]]; then
            gum style --foreground=33 "üìÅ Copying Claude configuration..."
            mkdir -p ".claude"
            
            # Copy all files from .claude directory
            for claude_file in "${REPO_ROOT}"/.claude/*; do
                if [[ -f "$claude_file" ]]; then
                    filename=$(basename "$claude_file")
                    cp "$claude_file" ".claude/$filename"
                    echo "  ‚úì Copied .claude/$filename"
                fi
            done
            
            # Copy subdirectories if any
            for claude_dir in "${REPO_ROOT}"/.claude/*/; do
                if [[ -d "$claude_dir" ]]; then
                    dirname=$(basename "$claude_dir")
                    cp -r "$claude_dir" ".claude/$dirname"
                    echo "  ‚úì Copied .claude/$dirname/"
                fi
            done
        fi
    fi
    
    # Install dependencies if package.json exists
    if [[ -f "package.json" ]]; then
        local pkg_manager=""
        
        # Detect package manager
        if [[ -f "${REPO_ROOT}/bun.lockb" ]] || [[ -f "${REPO_ROOT}/bun.lock" ]]; then
            pkg_manager="bun"
        elif [[ -f "${REPO_ROOT}/pnpm-lock.yaml" ]]; then
            pkg_manager="pnpm"
        elif [[ -f "${REPO_ROOT}/yarn.lock" ]]; then
            pkg_manager="yarn"
        else
            pkg_manager="npm"
        fi
        
        # Ask if user wants to install dependencies
        if gum confirm "Install dependencies with $pkg_manager?"; then
            gum spin --spinner dot --title "Installing dependencies with $pkg_manager..." -- \
                $pkg_manager install
        fi
    fi
    
    # Ask what to do next
    gum style --foreground=33 "What would you like to do next?"
    local choices=("Change to worktree directory" "Open in Claude Code" "Open in Cursor" "Open in VS Code" "Open in Finder" "Return to menu" "Exit")
    local choice
    choice=$(printf '%s\n' "${choices[@]}" | gum choose --limit=1)
    
    case "$choice" in
        "Change to worktree directory")
            gum style \
                --foreground=32 --border=rounded --padding="1 2" \
                "‚úÖ Worktree '$branch_name' created successfully!" \
                "üìç Path: $worktree_path"
            echo ""
            gum style --foreground=32 "üìÇ Changing to worktree directory..."
            echo ""
            gum style --foreground=37 "üí° Your shell will now be in: $worktree_path"
            echo ""
            # Change to the worktree directory and exit, leaving user in the new location
            cd "$worktree_path"
            exec "$SHELL"
            ;;
        "Open in Claude Code")
            if command -v claude >/dev/null 2>&1; then
                gum style \
                    --foreground=32 --border=rounded --padding="1 2" \
                    "‚úÖ Worktree '$branch_name' created successfully!" \
                    "üìç Path: $worktree_path"
                echo ""
                gum style \
                    --foreground=32 --bold \
                    "üöÄ Launching Claude Code..."
                gum style \
                    --foreground=37 \
                    "   Terminal will be taken over by Claude Code"
                echo ""
                sleep 1.5  # Brief pause to read the message
                claude .
                exit 0
            else
                gum style --foreground=196 "‚ùå Claude Code not found!"
            fi
            ;;
        "Open in Cursor")
            if command -v cursor >/dev/null 2>&1; then
                gum style --foreground=32 "üöÄ Opening in Cursor..."
                sleep 1
                cursor .
                exit 0
            else
                gum style --foreground=196 "‚ùå Cursor not found!"
            fi
            ;;
        "Open in VS Code")
            if command -v code >/dev/null 2>&1; then
                gum style --foreground=32 "üöÄ Opening in VS Code..."
                sleep 1
                code .
                exit 0
            else
                gum style --foreground=196 "‚ùå VS Code not found!"
            fi
            ;;
        "Open in Finder")
            gum style --foreground=32 "üöÄ Opening in Finder..."
            sleep 1
            open .
            exit 0
            ;;
        "Return to menu")
            # Just continue to the success message and return
            ;;
        "Exit"|"")
            gum style --foreground=32 "üëã Goodbye!"
            exit 0
            ;;
    esac
    
    # Only show success message if returning to menu
    if [[ "$choice" == "Return to menu" ]]; then
        gum style \
            --foreground=32 --border=rounded --padding="1 2" \
            "‚úÖ Worktree '$branch_name' created successfully!" \
            "üìç Path: $worktree_path"
    fi
}

# Delete worktree
delete_worktree() {
    get_repo_info
    
    # Get worktrees for selection
    local worktree_options=()
    local worktree_paths=()
    local worktree_branches=()
    
    while IFS= read -r line; do
        if [[ $line == *" "* ]]; then
            local path=$(echo "$line" | awk '{print $1}')
            local branch=$(echo "$line" | awk '{print $3}' | sed 's/\[//' | sed 's/\]//')
            if [[ "$path" != "$REPO_ROOT" ]]; then
                local name=$(basename "$path")
                worktree_options+=("$name (Branch: $branch)")
                worktree_paths+=("$path")
                worktree_branches+=("$branch")
            fi
        fi
    done < <(git worktree list)
    
    if [[ ${#worktree_options[@]} -eq 0 ]]; then
        gum style --foreground=33 "üìÇ No additional worktrees found to delete!"
        echo "üí° Create a worktree first to have something to delete."
        return 0
    fi
    
    gum style --foreground=33 "Select worktrees to delete (use Tab to select multiple, Enter to confirm):"
    local selected_items
    selected_items=$(printf '%s\n' "${worktree_options[@]}" | gum choose --no-limit)
    
    if [[ -z "$selected_items" ]]; then
        gum style --foreground=33 "‚úÖ Deletion cancelled!"
        return 0
    fi
    
    # Convert selected items to arrays for processing
    local selected_paths=()
    local selected_branches=()
    local selected_names=()
    
    while IFS= read -r selected; do
        # Find index of selected option
        local index=-1
        for i in "${!worktree_options[@]}"; do
            if [[ "${worktree_options[$i]}" == "$selected" ]]; then
                index=$i
                break
            fi
        done
        
        if [[ $index -ne -1 ]]; then
            selected_paths+=("${worktree_paths[$index]}")
            selected_branches+=("${worktree_branches[$index]}")
            selected_names+=("$(basename "${worktree_paths[$index]}")")
        fi
    done <<< "$selected_items"
    
    # Confirm deletion
    echo ""
    gum style --foreground=196 "‚ö†Ô∏è  This will permanently delete ${#selected_names[@]} worktree(s):"
    for i in "${!selected_names[@]}"; do
        echo "   üìÅ Worktree: ${selected_names[$i]}"
        echo "   üìç Path: ${selected_paths[$i]}"
        echo "   üåø Branch: ${selected_branches[$i]}"
        if [[ $i -lt $((${#selected_names[@]} - 1)) ]]; then
            echo ""
        fi
    done
    echo ""
    
    if ! gum confirm "Are you sure you want to delete these worktrees?"; then
        gum style --foreground=33 "‚úÖ Deletion cancelled!"
        return 0
    fi
    
    # Delete worktrees and branches
    echo ""
    local success_count=0
    local failed_count=0
    
    for i in "${!selected_paths[@]}"; do
        local worktree_path="${selected_paths[$i]}"
        local branch_name="${selected_branches[$i]}"
        local worktree_name="${selected_names[$i]}"
        
        echo "Processing: $worktree_name..."
        
        # Remove worktree
        local worktree_error
        worktree_error=$(git worktree remove "$worktree_path" 2>&1)
        local worktree_exit_code=$?
        
        if [[ $worktree_exit_code -eq 0 ]]; then
            # Delete branch
            if git branch -D "$branch_name" >/dev/null 2>&1; then
                gum style --foreground=32 "‚úÖ $worktree_name deleted successfully"
                ((success_count++))
            else
                gum style --foreground=33 "‚ö†Ô∏è  $worktree_name: worktree removed, branch deletion failed"
                ((success_count++))
            fi
        else
            gum style --foreground=196 "‚ùå $worktree_name: failed to remove"
            echo "   Error: $worktree_error"
            ((failed_count++))
        fi
    done
    
    echo ""
    gum style \
        --foreground=32 --border=rounded --padding="1 2" \
        "üéØ Deletion Summary:" \
        "‚úÖ Successfully deleted: $success_count" \
        "‚ùå Failed: $failed_count"
}

# Navigate to worktree
navigate_to_worktree() {
    get_repo_info
    
    # Get worktrees for selection
    local worktree_options=()
    local worktree_paths=()
    local current_path=$(pwd)
    
    # Add main repo first
    worktree_options+=("$(basename "$REPO_ROOT") (main repo)")
    worktree_paths+=("$REPO_ROOT")
    
    # Add additional worktrees
    while IFS= read -r line; do
        if [[ $line == *" "* ]]; then
            local path=$(echo "$line" | awk '{print $1}')
            local branch=$(echo "$line" | awk '{print $3}' | sed 's/\[//' | sed 's/\]//')
            if [[ "$path" != "$REPO_ROOT" ]]; then
                local name=$(basename "$path")
                if [[ "$path" == "$current_path" ]]; then
                    worktree_options+=("$name (Branch: $branch) [CURRENT]")
                else
                    worktree_options+=("$name (Branch: $branch)")
                fi
                worktree_paths+=("$path")
            fi
        fi
    done < <(git worktree list)
    
    if [[ ${#worktree_options[@]} -eq 1 ]]; then
        gum style --foreground=33 "üìÇ Only main repository available!"
        echo "üí° Create worktrees first to navigate between them."
        return 0
    fi
    
    gum style --foreground=33 "Select worktree to navigate to:"
    local selected_item
    selected_item=$(printf '%s\n' "${worktree_options[@]}" | gum choose --limit=1)
    
    if [[ -z "$selected_item" ]]; then
        gum style --foreground=33 "‚úÖ Navigation cancelled!"
        return 0
    fi
    
    # Find index of selected option
    local index=-1
    for i in "${!worktree_options[@]}"; do
        if [[ "${worktree_options[$i]}" == "$selected_item" ]]; then
            index=$i
            break
        fi
    done
    
    if [[ $index -eq -1 ]]; then
        gum style --foreground=196 "‚ùå Selection not found!"
        return 1
    fi
    
    local target_path="${worktree_paths[$index]}"
    
    if [[ "$target_path" == "$current_path" ]]; then
        gum style --foreground=33 "üëç Already in selected location!"
        return 0
    fi
    
    # Navigate to selected worktree
    gum style --foreground=32 "üöÄ Navigating to: $(basename "$target_path")"
    echo "üìç Path: $target_path"
    echo ""
    gum style --foreground=37 "üí° Your shell will now be in the selected worktree"
    echo ""
    cd "$target_path"
    exec "$SHELL"
}

# Show worktree status
show_status() {
    get_repo_info
    
    gum style \
        --foreground=34 --border=thick --padding="1 2" \
        "üå≥ Git Worktrees for $PROJECT_NAME"
    
    # Show main repo first
    gum style --foreground=32 "üìÅ Main Repository:"
    echo "   üìç Path: $REPO_ROOT"
    local main_branch=$(git branch --show-current)
    if [[ -n "$main_branch" ]]; then
        echo "   üåø Branch: $main_branch"
    fi
    echo ""
    
    # Show worktrees with detailed info
    local found_worktrees=false
    while IFS= read -r line; do
        if [[ $line == *" "* ]]; then
            local path=$(echo "$line" | awk '{print $1}')
            local branch=$(echo "$line" | awk '{print $3}' | sed 's/\[//' | sed 's/\]//')
            if [[ "$path" != "$REPO_ROOT" ]]; then
                if [[ "$found_worktrees" == false ]]; then
                    gum style --foreground=32 "üìÇ Additional Worktrees:"
                    found_worktrees=true
                fi
                echo ""
                gum style --foreground=33 "üìÅ Worktree: $(basename "$path")"
                echo "   üìç Path: $path"
                if [[ "$branch" == "(detached" ]]; then
                    echo "   üîÄ Branch: (detached HEAD)"
                else
                    echo "   üåø Branch: $branch"
                fi
            fi
        fi
    done < <(git worktree list)
    
    if [[ "$found_worktrees" == false ]]; then
        gum style --foreground=37 "üìÇ No additional worktrees found"
    fi
}

# Main menu
main_menu() {
    while true; do
        clear
        
        # Header
        gum style \
            --foreground=34 --bold \
            "üå≥ Git Worktree Manager"
        
        get_repo_info
        gum style --foreground=37 "Project: $PROJECT_NAME"
        echo ""
        
        # Menu options
        local choices=("Create new worktree" "Navigate to worktree" "List worktrees" "Delete worktree" "Quit")
        local choice
        choice=$(printf '%s\n' "${choices[@]}" | gum choose --limit=1 --height=6)
        
        case "$choice" in
            "Create new worktree")
                echo ""
                create_worktree
                echo ""
                gum style --foreground=37 "Press any key to continue..."
                read -n 1 -s
                ;;
            "Navigate to worktree")
                echo ""
                navigate_to_worktree
                # No "press any key" here since we're changing shells
                ;;
            "List worktrees")
                echo ""
                show_status
                echo ""
                gum style --foreground=37 "Press any key to continue..."
                read -n 1 -s
                ;;
            "Delete worktree")
                echo ""
                delete_worktree
                echo ""
                gum style --foreground=37 "Press any key to continue..."
                read -n 1 -s
                ;;
            "Quit"|"")
                gum style --foreground=32 "üëã Goodbye!"
                exit 0
                ;;
        esac
    done
}

# Main execution
main() {
    check_git_repo
    main_menu
}

# Run main function
main "$@"